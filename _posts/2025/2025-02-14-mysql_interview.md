---
layout: post
title: "MySQL常见面试题"
date: 2025-02-14
tags: [MySQL, 面试]
comments: false
author: 小辣条
toc : true
---
收集了一些MySQL方面常见的面试题，希望对大家有帮助
<!-- more -->

# 1、select * .... for update语句是行锁还是表锁？
没用索引/主键的话就是表锁，否则就是是行锁。
作用：用于在事务中锁定满足条件的行，确保在事务结束前其他事务无法修改这些行
```
BEGIN;
-- 锁定 id = 'xxx' 的行
SELECT * FROM order_table WHERE id = 'xxx' FOR UPDATE;
-- 更新操作
UPDATE order_table SET status = 'processed' WHERE id = 'xxx';
COMMIT;
```

# 2、一条sql的执行过程是怎样的？



# 3、数据库都有哪些锁？
- InnoDB 中实现了两个标准的`行级锁`，可以简单的看为两个读写锁，一个是共享锁（S Lock），一个是排他锁（X Lock）。
- 意向锁在InnoDB中是`表级锁`：`意向共享锁`表达一个事务想要获取一张表中某几行的共享锁;`意向排他锁`表达一个事务想要获取一张表中某几行的排他锁。
- `自增锁`：在InnoDB中，如果表中有一个自增字段，那么在插入新记录时，InnoDB会对这个自增字段加锁，以防止并发插入导致的主键冲突。
- `间隙锁`：间隙锁是锁定一个范围，而不是单个值。在InnoDB中，如果一个事务执行范围查询并使用范围内的索引，InnoDB会对这个范围的索引加锁，以防止其他事务插入这个范围的记录。

InnoDB的锁算法：
记录锁是锁住记录的，这里要说明的是这里锁住的是索引记录，而不是我们真正的数据记录
间隙锁锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫 gap 锁，其不会阻塞其他的 gap 锁，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。
next-key锁 = 记录锁 + 间隙锁，是InnoDB的默认锁算法，可以解决幻读问题。如果查询扫描中有唯一索引会退化成只使用记录锁。为什么呢? 因为唯一索引能确定行数，而其他索引不能确定行数，有可能在其他事务中会再次添加这个索引的数据造成幻读。
[参考文章Todo](https://cloud.tencent.com/developer/article/1520323)

# 4、常见的术语
- DDL、DML、DQL、CRUD

# 5、事务的隔离级别有哪些？
事务的隔离性通过隔离级别来控制并发事务之间的可见性和影响范围。MySQL中定义了四种隔离级别，分别是：
- `READ UNCOMMITTED`：未提交读，事务可以读取未提交的数据，可能会导致脏读、不可重复读、幻读。
- `READ COMMITTED`：提交读，事务只能读取已提交的数据，可以避免脏读，但是可能会导致不可重复读、幻读。
- `REPEATABLE READ`：可重复读，事务在整个过程中看到的数据是一致的，可以避免脏读、不可重复读
- 串行化：事务串行执行，可以避免脏读、不可重复读、幻读。

# 6、脏读、不可重复读、幻读分别是什么？
- `脏读`：一个事务读取到了另一个事务未提交的数据，导致读取到了不正确的数据。
- `不可重复读`：一个事务在读取数据的过程中，另一个事务修改了数据，导致两次读取的数据不一致。
- `幻读`：一个事务在读取数据的过程中，另一个事务插入了新的数据，导致两次读取的数据不一致。

# 7、数据库事务的四种特性？

![alt text](https://raw.githubusercontent.com/swh0318/swh0318.github.io/refs/heads/main/_posts/2025/assets/2025-02-14-mysql_interview/image.png)

