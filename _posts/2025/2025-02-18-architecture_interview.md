---
layout: post
title: "系统架构常见面试题"
date: 2025-02-18
tags: [系统架构, 架构设计, 面试]
comments: false
author: 小辣条
toc : true
---
收集了一些系统架构方面常见的面试题，希望对大家有帮助
<!-- more -->

# 1、如何保证告警系统中的实时性、覆盖率和高可用？
```
实时性：优化链路性能
送达率：多通道发送、重试机制
高可用：多副本、做告警的告警、链路探测机制、定期故障演练、可观测快速恢复
```
# 2、如何设计一个高可用和高并发的短信系统？
```
1、实时高的验证码短信同步发送，其余异步发送，提高系统的吞吐量
2、短信发送失败重试机制，单通道重试+跨通道重试
3、接多家运营商，每家运营商的比例后台可调，保证计划停服时，短信发送不受影响
4、定时任务探测：短信发送失败率和延迟率，及时自动切换通道
5、对于质量不好的通道，可以使用固定短信探测，保证通道自动恢复。
6、后台增加补救入口，用于事后补发相关短信
7、添加相关日志和告警，及时发现问题
```
# 3、如何设计一个高可用的id生成器？
```
```
# 4、如何设计一个缓存系统？
```
```
# 5、如何设计一个秒杀系统？
```
```
# 6、如何设计一个高可用的分布式锁？

功能：互斥、可重入性、锁超时、支持阻塞和非阻塞、支持公平锁和非公平锁

### MySQL:
- 适用场景：MySQL 分布式锁一般适用于资源不存在数据库，如果数据库存在比如订单，可以直接对这条数据加行锁，不需要我们上面多的繁琐的步骤。比如一个订单，我们可以用 select * from order_table where id = 'xxx' for update 进行加行锁，那么其他的事务就不能对其进行修改。
- 优点：理解起来简单，不需要维护额外的第三方中间件(比如 Redis，ZK)
- 缺点：虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。
`乐观锁`: 保证我们并发的顺序执行使用乐观锁进行处理，我们可以对我们的表加一个版本号字段。

### ZK
ZooKeeper是以Paxos算法为基础的分布式应用程序协调服务。ZK的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。
![alt text](https://raw.githubusercontent.com/swh0318/swh0318.github.io/refs/heads/main/_posts/2025/assets/2025-02-18-architecture_interview/image.png)
`Curator`封装了ZooKeeper底层的API，使我们更加容易方便的ZooKeeper进行操作，并且它封装了分布式锁的功能

- 优点：ZK 可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用ZK集群进行保证。
- 缺点：ZK 需要额外维护，增加维护成本，性能和 MySQL 相差不大，依然比较差。并且需要开发人员了解ZK是什么。

### Redis
利用setNx(set if not exist) 方法不陌生，如果不存在则更新，其可以很好的用来实现我们的分布式锁。

`Redission` 也是 Redis 的客户端，相比于 Jedis 功能简单。Jedis 简单使用阻塞的 I/O 和 Redis 交互，Redission 通过 Netty 支持非阻塞 I/O。

`RedLock` 是 Redisson 提供的一种分布式锁的实现，其基于多个 Redis 节点实现的分布式锁。RedLock 通过多个 Redis 节点的协作来实现分布式锁，其算法是基于 Paxos 算法的。 RedLock 基本原理是利用多个 Redis 集群，用多数的集群加锁成功，减少 Redis 某个集群出故障，造成分布式锁出现问题的概率。

Redis 小结：
- 优点：对于 Redis 实现简单，性能对比 ZK 和 MySQL 较好。如果不需要特别复杂的要求，自己就可以利用 setNx 进行实现，如果自己需要复杂的需求的话，可以利用或者借鉴 Redission。对于一些要求比较严格的场景可以使用 RedLock。
- 缺点：需要维护 Redis 集群，如果要实现 RedLock 需要维护更多的集群。

### 自研分布式锁

参考文章: https://mp.weixin.qq.com/s/hoZB0wdwXfG3ECKlzjtPdw

# 7、如何设计一个高可用的分布式事务？
```
```
# 8、如何设计一个高可用的分布式调度系统？
```
```
# 9、如何设计一个高可用的短域名系统？
```
```
# 10、如何设计一个高可用的分布式消息队列？
```
```
# 11、你了解哪些分布式id生成的机制或模块？
- java uuid: 无顺
- 数据库自增id: 有顺序，性能不高
- redis incr: 有顺序，性能高；可能会重复
- zookeeper: 性能不高
- 数据库分段+服务缓存ID: 有顺序，性能高 
- snowflake: 有顺序，性能高，不会重复
1bit:一般是符号位，不做处理
41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。
10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心，后面5位是某个数据中心的机器ID
12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。

